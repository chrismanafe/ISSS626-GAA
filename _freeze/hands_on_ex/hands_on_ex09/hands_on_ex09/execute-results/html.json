{
  "hash": "243132be1c4f195921556ee9f0ef565d",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Hands-on Exercise 9: Modelling Geographical Accessibility\"\nauthor: \"Christover Manafe\"\ndate: \"2024-10-21\"\ndate-modified: \"last-modified\"\nexecute: \n  eval: true\n  echo: true\n  message: false\n  freeze: true\nformat: \n  html:\n    code-fold: false\n    code-summary: \"code chunk\"\n    number-sections: true\n    number-depth: 4\n---\n\n\n# Overview\n\nIn this hands-on exercise, we will learn how to model geographical accessibility by using Râ€™s geospatial analysis packages.\n\n# The data\n\nFour datasets will be used in this hands-on exercise:\n\n1.  **MP14_SUBZONE_NO_SEA_PL**:\\\n    This is the URA Master Plan 2014 subzone boundary GIS data, downloaded from [data.gov.sg](https://data.gov.sg).\n\n2.  **Hexagons**:\\\n    A GIS dataset consisting of hexagons with a 250m radius. This dataset was created using the `st_make_grid()` function from the `sf` package and is provided in ESRI shapefile format.\n\n3.  **ELDERCARE**:\\\n    This dataset contains GIS data showing the locations of eldercare services, downloaded from [data.gov.sg](https://data.gov.sg). There are two versions available:\n\n    -   ESRI shapefile format\n\n    -   Google KML file format\\\n        For this hands-on exercise, the ESRI shapefile format is provided.\n\n4.  **OD_Matrix**:\\\n    A distance matrix in CSV format. The file contains six fields:\n\n    -   **origin_id**: Unique ID values of the origin (i.e., FID of the hexagon dataset).\n\n    -   **destination_id**: Unique ID values of the destination (i.e., FID of the ELDERCARE dataset).\n\n    -   **entry_cost**: The perpendicular distance between the origins and the nearest road.\n\n    -   **network_cost**: The actual network distance between the origin and destination.\n\n    -   **exit_cost**: The perpendicular distance between the destination and the nearest road.\n\n    -   **total_cost**: The sum of entry_cost, network_cost, and exit_cost.\n\n    All values in the cost-related fields are measured in meters.\n\n::: callout-important\nExcept for the **MP14_SUBZONE_NO_SEA_PL** dataset, the other three datasets were specially prepared by Prof. Kam for teaching and research purposes.\n:::\n\n# The Packages\n\nWe will use following packages in this exercise\n\n::: panel-tabset\n## Packages\n\nWe will use following packages in this exercise:\n\n| **Package**                                                                       | **Description**                                                                                                                                                                                                   |\n|---------------------|---------------------------------------------------|\n| [**sf**](https://r-spatial.github.io/sf/)                                         | Provides functions to manage, process, and manipulate **Simple Features**, a formal geospatial data standard that specifies a storage and access model of spatial geometries such as points, lines, and polygons. |\n| [**tidyverse**](https://www.tidyverse.org/)                                       | A collection of R packages for data science tasks such as importing, tidying, wrangling, and visualizing data.                                                                                                    |\n| [**tmap**](https://cran.r-project.org/web/packages/tmap/)                         | Provides functions for creating cartographic-quality static maps or interactive maps using the [leaflet](https://leafletjs.com/) API.                                                                             |\n| [**SpatialAcc**](https://cran.r-project.org/web/packages/SpatialAcc/index.html)   | Provides a set of spatial accessibility measures from a set of locations (demand) to another set of locations (supply)                                                                                            |\n| [**ggstatsplot**](https://cran.r-project.org/web/packages/ggstatsplot/index.html) | Provides functions to creates graphics with details from statistical tests included in the plots themselves.                                                                                                      |\n| [**reshape2**](https://cran.r-project.org/web/packages/reshape2/index.html)       | Provides functions to flexibly reshape data.                                                                                                                                                                      |\n\n: {tbl-colwidths=\"\\[15,85\\]\"}\n\n## Code\n\nTo install and launch all R packages.\n\n\n::: {.cell}\n\n```{.r .cell-code}\npacman::p_load(tmap, SpatialAcc, sf, ggstatsplot, reshape2, tidyverse)\n```\n:::\n\n:::\n\n# Geospatial Data Wrangling\n\n## Importing Geospatial Data\n\nThree geospatial datasets will be imported from the `data/geospatial` sub-folder: **MP14_SUBZONE_NO_SEA_PL**, **hexagons**, and **ELDERCARE**.\n\nWe will use the `st_read()` function from the `sf` package to import these datasets.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmpsz <- st_read(dsn = \"data/geospatial\", layer = \"MP14_SUBZONE_NO_SEA_PL\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nReading layer `MP14_SUBZONE_NO_SEA_PL' from data source \n  `/Users/cham/project/Geospatial-Analytics/chrismanafe/ISSS626-GAA/hands_on_ex/hands_on_ex09/data/geospatial' \n  using driver `ESRI Shapefile'\nSimple feature collection with 323 features and 15 fields\nGeometry type: MULTIPOLYGON\nDimension:     XY\nBounding box:  xmin: 2667.538 ymin: 15748.72 xmax: 56396.44 ymax: 50256.33\nProjected CRS: SVY21\n```\n\n\n:::\n\n```{.r .cell-code}\nhexagons <- st_read(dsn = \"data/geospatial\", layer = \"hexagons\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nReading layer `hexagons' from data source \n  `/Users/cham/project/Geospatial-Analytics/chrismanafe/ISSS626-GAA/hands_on_ex/hands_on_ex09/data/geospatial' \n  using driver `ESRI Shapefile'\nSimple feature collection with 3125 features and 6 fields\nGeometry type: POLYGON\nDimension:     XY\nBounding box:  xmin: 2667.538 ymin: 21506.33 xmax: 50010.26 ymax: 50256.33\nProjected CRS: SVY21 / Singapore TM\n```\n\n\n:::\n\n```{.r .cell-code}\neldercare <- st_read(dsn = \"data/geospatial\", layer = \"ELDERCARE\") \n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nReading layer `ELDERCARE' from data source \n  `/Users/cham/project/Geospatial-Analytics/chrismanafe/ISSS626-GAA/hands_on_ex/hands_on_ex09/data/geospatial' \n  using driver `ESRI Shapefile'\nSimple feature collection with 120 features and 19 fields\nGeometry type: POINT\nDimension:     XY\nBounding box:  xmin: 14481.92 ymin: 28218.43 xmax: 41665.14 ymax: 46804.9\nProjected CRS: SVY21 / Singapore TM\n```\n\n\n:::\n:::\n\n\n> The report above shows that the R object containing the imported **MP14_SUBZONE_WEB_PL** shapefile is called `mpsz`, and it is a simple feature (sf) object. The geometry type is **multipolygon**. It's also important to note that the `mpsz` simple feature object does not have EPSG information.\n\nThe code chunk below updates the newly imported `mpsz` object with the correct EPSG code (i.e., 3414):\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmpsz <- st_transform(mpsz, 3414)\neldercare <- st_transform(eldercare, 3414)\nhexagons <- st_transform(hexagons, 3414)\n```\n:::\n\n\nAfter transforming the projection metadata, we can verify the projection of the newly transformed `mpsz` object by using the `st_crs()` function from the `sf` package.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nst_crs(mpsz)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nCoordinate Reference System:\n  User input: EPSG:3414 \n  wkt:\nPROJCRS[\"SVY21 / Singapore TM\",\n    BASEGEOGCRS[\"SVY21\",\n        DATUM[\"SVY21\",\n            ELLIPSOID[\"WGS 84\",6378137,298.257223563,\n                LENGTHUNIT[\"metre\",1]]],\n        PRIMEM[\"Greenwich\",0,\n            ANGLEUNIT[\"degree\",0.0174532925199433]],\n        ID[\"EPSG\",4757]],\n    CONVERSION[\"Singapore Transverse Mercator\",\n        METHOD[\"Transverse Mercator\",\n            ID[\"EPSG\",9807]],\n        PARAMETER[\"Latitude of natural origin\",1.36666666666667,\n            ANGLEUNIT[\"degree\",0.0174532925199433],\n            ID[\"EPSG\",8801]],\n        PARAMETER[\"Longitude of natural origin\",103.833333333333,\n            ANGLEUNIT[\"degree\",0.0174532925199433],\n            ID[\"EPSG\",8802]],\n        PARAMETER[\"Scale factor at natural origin\",1,\n            SCALEUNIT[\"unity\",1],\n            ID[\"EPSG\",8805]],\n        PARAMETER[\"False easting\",28001.642,\n            LENGTHUNIT[\"metre\",1],\n            ID[\"EPSG\",8806]],\n        PARAMETER[\"False northing\",38744.572,\n            LENGTHUNIT[\"metre\",1],\n            ID[\"EPSG\",8807]]],\n    CS[Cartesian,2],\n        AXIS[\"northing (N)\",north,\n            ORDER[1],\n            LENGTHUNIT[\"metre\",1]],\n        AXIS[\"easting (E)\",east,\n            ORDER[2],\n            LENGTHUNIT[\"metre\",1]],\n    USAGE[\n        SCOPE[\"Cadastre, engineering survey, topographic mapping.\"],\n        AREA[\"Singapore - onshore and offshore.\"],\n        BBOX[1.13,103.59,1.47,104.07]],\n    ID[\"EPSG\",3414]]\n```\n\n\n:::\n:::\n\n\n> Notice that the EPSG code is now indicated as **3414**.\n\n## Cleaning and updating attribute fields of the geospatial data\n\nThere are several redundant fields in the data tables of both the **eldercare** and **hexagons** datasets. The code chunks below will be used to exclude those redundant fields. Additionally, a new field called **demand** will be added to the **hexagons** data table, and a new field called **capacity** will be added to the **eldercare** data table. Both fields will be derived using the `mutate()` function from the `dplyr` package.\n\n\n::: {.cell}\n\n```{.r .cell-code}\neldercare <- eldercare %>%\n  select(fid, ADDRESSPOS) %>%\n  mutate(capacity = 100)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nhexagons <- hexagons %>%\n  select(fid) %>%\n  mutate(demand = 100)\n```\n:::\n\n\n> Note that for the purpose of this hands-on exercise, a constant value of 100 is used. In practice, the actual demand for each hexagon and the capacity of each eldercare center should be used.\n\n# Aspatial Data Handling and Wrangling\n\n## Importing Distance Matrix\n\nThe code chunk below uses the `read_csv()` function from the `readr` package to import **OD_Matrix.csv** into RStudio. The imported object is a tibble data frame called **ODMatrix**.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nODMatrix <- read_csv(\"data/aspatial/OD_Matrix.csv\", skip = 0)\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nRows: 375000 Columns: 6\nâ”€â”€ Column specification â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\nDelimiter: \",\"\ndbl (6): origin_id, destination_id, entry_cost, network_cost, exit_cost, tot...\n\nâ„¹ Use `spec()` to retrieve the full column specification for this data.\nâ„¹ Specify the column types or set `show_col_types = FALSE` to quiet this message.\n```\n\n\n:::\n:::\n\n\n## Tidying distance matrix\n\nThe imported **ODMatrix** organizes the distance matrix in a column-wise format.\n\nHowever, most modeling packages in R expect a matrix structure where the rows represent **origins** (also known as the **from** field) and the columns represent **destinations** (also known as the **to** field).\n\nThe code chunk below uses the `spread()` function from the **tidyr** package to transform the O-D matrix from a \"thin\" format to a \"wide\" format.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndistmat <- ODMatrix %>%\n  select(origin_id, destination_id, total_cost) %>%\n  spread(destination_id, total_cost)%>%\n  select(c(-c('origin_id')))\n```\n:::\n\n\nCurrently, the distances are measured in meters because the SVY21 projected coordinate system is used. The code chunk below will be used to convert the unit of measurement from meters to kilometers.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndistmat_km <- as.matrix(distmat/1000)\n```\n:::\n\n\n# Modelling and Visualising Accessibility using Hansen Method\n\n## Computing Hansen's accessibility\n\nWe are now ready to compute Hansenâ€™s accessibility using the `ac()` function from the [**SpatialAcc**](https://cran.r-project.org/web/packages/SpatialAcc/index.html) package. Before getting started, it is encouraged to review the function's arguments to ensure all required inputs are available.\n\nThe code chunk below calculates Hansenâ€™s accessibility using `ac()` from **SpatialAcc**, and `data.frame()` is used to save the output in a data frame called **acc_Hansen**.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nacc_Hansen <- data.frame(ac(hexagons$demand,\n                            eldercare$capacity,\n                            distmat_km, \n                            #d0 = 50,\n                            power = 2, \n                            family = \"Hansen\"))\nhead(acc_Hansen)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n  ac.hexagons.demand..eldercare.capacity..distmat_km..power...2..\n1                                                    1.648313e-14\n2                                                    1.096143e-16\n3                                                    3.865857e-17\n4                                                    1.482856e-17\n5                                                    1.051348e-17\n6                                                    5.076391e-18\n```\n\n\n:::\n:::\n\n\nThe default field names are quite messy, so we will rename them to **accHansen** using the code chunk below.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncolnames(acc_Hansen) <- \"accHansen\"\nhead(acc_Hansen)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n     accHansen\n1 1.648313e-14\n2 1.096143e-16\n3 3.865857e-17\n4 1.482856e-17\n5 1.051348e-17\n6 5.076391e-18\n```\n\n\n:::\n:::\n\n\nNext, we will convert the data table into a tibble format using the code chunk below.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nacc_Hansen <- as_tibble(acc_Hansen)\n```\n:::\n\n\nLastly, the `bind_cols()` function from **dplyr** will be used to join the **acc_Hansen** tibble with the **hexagons** simple feature data frame. The output will be called **hexagon_Hansen**.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhexagon_Hansen <- bind_cols(hexagons, acc_Hansen)\n\nhead(hexagon_Hansen)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nSimple feature collection with 6 features and 3 fields\nGeometry type: POLYGON\nDimension:     XY\nBounding box:  xmin: 2667.538 ymin: 22756.33 xmax: 3244.888 ymax: 27756.33\nProjected CRS: SVY21 / Singapore TM\n  fid demand    accHansen                       geometry\n1   1    100 1.648313e-14 POLYGON ((2667.538 27506.33...\n2   2    100 1.096143e-16 POLYGON ((2667.538 25006.33...\n3   3    100 3.865857e-17 POLYGON ((2667.538 24506.33...\n4   4    100 1.482856e-17 POLYGON ((2667.538 24006.33...\n5   5    100 1.051348e-17 POLYGON ((2667.538 23506.33...\n6   6    100 5.076391e-18 POLYGON ((2667.538 23006.33...\n```\n\n\n:::\n:::\n\n\n## Visualising Hansenâ€™s accessibility\n\n### Extracting map extend\n\nFirst, we will extract the extent of the **hexagons** simple feature data frame using the `st_bbox()` function from the **sf** package.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmapex <- st_bbox(hexagons)\n```\n:::\n\n\nThe code chunk below uses a collection of mapping functions from the **tmap** package to create a high-quality cartographic map showing accessibility to eldercare centers in Singapore.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntmap_mode(\"plot\")\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\ntmap mode set to plotting\n```\n\n\n:::\n\n```{.r .cell-code}\ntm_shape(hexagon_Hansen,\n         bbox = mapex) + \n  tm_fill(col = \"accHansen\",\n          n = 10,\n          style = \"quantile\",\n          border.col = \"black\",\n          border.lwd = 1) +\ntm_shape(eldercare) +\n  tm_symbols(size = 0.1) +\n  tm_layout(main.title = \"Accessibility to eldercare: Hansen method\",\n            main.title.position = \"center\",\n            main.title.size = 2,\n            legend.outside = FALSE,\n            legend.height = 0.45, \n            legend.width = 3.0,\n            legend.format = list(digits = 6),\n            legend.position = c(\"right\", \"top\"),\n            frame = TRUE) +\n  tm_compass(type=\"8star\", size = 2) +\n  tm_scale_bar(width = 0.15) +\n  tm_grid(lwd = 0.1, alpha = 0.5)\n```\n\n::: {.cell-output-display}\n![](hands_on_ex09_files/figure-html/unnamed-chunk-15-1.png){width=1152}\n:::\n:::\n\n\n## Statistical graphic visualisation\n\nIn this section, we will compare the distribution of Hansenâ€™s accessibility values by URA Planning Region.\n\nFirst, we need to add the planning region field to the **hexagon_Hansen** simple feature data frame using the code chunk below.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhexagon_Hansen <- st_join(hexagon_Hansen, mpsz, \n                          join = st_intersects)\n```\n:::\n\n\nNext, we will use `ggplot()` to plot the distribution of Hansen's accessibility values using the boxplot graphical method.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(data=hexagon_Hansen, \n       aes(y = log(accHansen), \n           x= REGION_N)) +\n  geom_boxplot() +\n  geom_point(stat=\"summary\", \n             fun.y=\"mean\", \n             colour =\"red\", \n             size=2)\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nWarning in geom_point(stat = \"summary\", fun.y = \"mean\", colour = \"red\", :\nIgnoring unknown parameters: `fun.y`\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nNo summary function supplied, defaulting to `mean_se()`\n```\n\n\n:::\n\n::: {.cell-output-display}\n![](hands_on_ex09_files/figure-html/unnamed-chunk-17-1.png){width=672}\n:::\n:::\n\n\n# Modelling and Visualising Accessibility using KD2SFCA Method\n\n## Computing KD2SFCAâ€™s accessibility\n\nNow, we will calculate Hansenâ€™s accessibility using the `ac()` function from the **SpatialAcc** package, and the output will be saved in a data frame called **acc_KD2SFCA**. Note that **KD2SFCA** is used for the `family` argument.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nacc_KD2SFCA <- data.frame(ac(hexagons$demand,\n                            eldercare$capacity,\n                            distmat_km, \n                            d0 = 50,\n                            power = 2, \n                            family = \"KD2SFCA\"))\n\ncolnames(acc_KD2SFCA) <- \"accKD2SFCA\"\nacc_KD2SFCA <- tbl_df(acc_KD2SFCA)\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nWarning: `tbl_df()` was deprecated in dplyr 1.0.0.\nâ„¹ Please use `tibble::as_tibble()` instead.\n```\n\n\n:::\n\n```{.r .cell-code}\nhexagon_KD2SFCA <- bind_cols(hexagons, acc_KD2SFCA)\n```\n:::\n\n\n## Visualising KD2SFCAâ€™s accessibility\n\nThe code chunk below uses a collection of mapping functions from the **tmap** package to create a high-quality cartographic map showing accessibility to eldercare centers in Singapore. Note that **mapex** is reused for the `bbox` argument.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntmap_mode(\"plot\")\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\ntmap mode set to plotting\n```\n\n\n:::\n\n```{.r .cell-code}\ntm_shape(hexagon_KD2SFCA,\n         bbox = mapex) + \n  tm_fill(col = \"accKD2SFCA\",\n          n = 10,\n          style = \"quantile\",\n          border.col = \"black\",\n          border.lwd = 1) +\ntm_shape(eldercare) +\n  tm_symbols(size = 0.1) +\n  tm_layout(main.title = \"Accessibility to eldercare: KD2SFCA method\",\n            main.title.position = \"center\",\n            main.title.size = 2,\n            legend.outside = FALSE,\n            legend.height = 0.45, \n            legend.width = 3.0,\n            legend.format = list(digits = 6),\n            legend.position = c(\"right\", \"top\"),\n            frame = TRUE) +\n  tm_compass(type=\"8star\", size = 2) +\n  tm_scale_bar(width = 0.15) +\n  tm_grid(lwd = 0.1, alpha = 0.5)\n```\n\n::: {.cell-output-display}\n![](hands_on_ex09_files/figure-html/unnamed-chunk-19-1.png){width=1152}\n:::\n:::\n\n\n## Statistical graphic visualisation\n\nNow, we will compare the distribution of KD2SFCA accessibility values by URA Planning Region.\n\nFirst, we need to add the planning region field to the **hexagon_KD2SFCA** simple feature data frame using the code chunk below.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhexagon_KD2SFCA <- st_join(hexagon_KD2SFCA, mpsz, \n                          join = st_intersects)\n```\n:::\n\n\nNext, we will use `ggplot()` to plot the distribution of KD2SFCA accessibility values using the boxplot graphical method.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(data=hexagon_KD2SFCA, \n       aes(y = accKD2SFCA, \n           x= REGION_N)) +\n  geom_boxplot() +\n  geom_point(stat=\"summary\", \n             fun.y=\"mean\", \n             colour =\"red\", \n             size=2)\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nWarning in geom_point(stat = \"summary\", fun.y = \"mean\", colour = \"red\", :\nIgnoring unknown parameters: `fun.y`\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nNo summary function supplied, defaulting to `mean_se()`\n```\n\n\n:::\n\n::: {.cell-output-display}\n![](hands_on_ex09_files/figure-html/unnamed-chunk-21-1.png){width=672}\n:::\n:::\n\n\n# Modelling and Visualising Accessibility using Spatial Accessibility Measure (SAM) Method\n\n## Computing SAM accessibility\n\nIn this section, we will repeat most of the steps learned in the previous section to perform the analysis. However, some of the code will be combined into a single code chunk.\n\nThe code chunk below calculates Hansenâ€™s accessibility using the `ac()` function from the **SpatialAcc** package, and the output is saved in a data frame called **acc_SAM**. Note that `SAM` is used for the family argument.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nacc_SAM <- data.frame(ac(hexagons$demand,\n                         eldercare$capacity,\n                         distmat_km, \n                         d0 = 50,\n                         power = 2, \n                         family = \"SAM\"))\n\ncolnames(acc_SAM) <- \"accSAM\"\nacc_SAM <- tbl_df(acc_SAM)\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nWarning: `tbl_df()` was deprecated in dplyr 1.0.0.\nâ„¹ Please use `tibble::as_tibble()` instead.\n```\n\n\n:::\n\n```{.r .cell-code}\nhexagon_SAM <- bind_cols(hexagons, acc_SAM)\n```\n:::\n\n\n## Visualising SAMâ€™s accessibility\n\nThe code chunk below uses a collection of mapping functions from the **tmap** package to create a high-quality cartographic map showing accessibility to eldercare centers in Singapore. Note that **mapex** is reused for the `bbox` argument.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntmap_mode(\"plot\")\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\ntmap mode set to plotting\n```\n\n\n:::\n\n```{.r .cell-code}\ntm_shape(hexagon_SAM,\n         bbox = mapex) + \n  tm_fill(col = \"accSAM\",\n          n = 10,\n          style = \"quantile\",\n          border.col = \"black\",\n          border.lwd = 1) +\ntm_shape(eldercare) +\n  tm_symbols(size = 0.1) +\n  tm_layout(main.title = \"Accessibility to eldercare: SAM method\",\n            main.title.position = \"center\",\n            main.title.size = 2,\n            legend.outside = FALSE,\n            legend.height = 0.45, \n            legend.width = 3.0,\n            legend.format = list(digits = 3),\n            legend.position = c(\"right\", \"top\"),\n            frame = TRUE) +\n  tm_compass(type=\"8star\", size = 2) +\n  tm_scale_bar(width = 0.15) +\n  tm_grid(lwd = 0.1, alpha = 0.5)\n```\n\n::: {.cell-output-display}\n![](hands_on_ex09_files/figure-html/unnamed-chunk-23-1.png){width=1152}\n:::\n:::\n\n\n## Statistical graphic visualisation\n\nNow, we will compare the distribution of SAM accessibility values by URA Planning Region.\n\nFirst, we need to add the planning region field to the **hexagon_SAM** simple feature data frame using the code chunk below.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhexagon_SAM <- st_join(hexagon_SAM, mpsz, \n                       join = st_intersects)\n```\n:::\n\n\nNext, ggplot() will be used to plot the distribution by using boxplot graphical method.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(data=hexagon_SAM, \n       aes(y = accSAM, \n           x= REGION_N)) +\n  geom_boxplot() +\n  geom_point(stat=\"summary\", \n             fun.y=\"mean\", \n             colour =\"red\", \n             size=2)\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nWarning in geom_point(stat = \"summary\", fun.y = \"mean\", colour = \"red\", :\nIgnoring unknown parameters: `fun.y`\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nNo summary function supplied, defaulting to `mean_se()`\n```\n\n\n:::\n\n::: {.cell-output-display}\n![](hands_on_ex09_files/figure-html/unnamed-chunk-25-1.png){width=672}\n:::\n:::\n\n\n# Reference\n\nKam, T. S. Modelling Geographical Accessibility. *R for Geospatial Data Science and Analytics.* <https://r4gdsa.netlify.app/chap17.html>\n",
    "supporting": [
      "hands_on_ex09_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}
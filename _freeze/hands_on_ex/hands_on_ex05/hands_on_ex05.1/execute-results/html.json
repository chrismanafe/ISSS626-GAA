{
  "hash": "072e0ee9eebe0e77b2e84fa36e5295fd",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Hands-on Exercise 5a: Global Measures of Spatial Autocorrelation\"\nauthor: \"Christover Manafe\"\ndate: \"2024-09-18\"\ndate-modified: \"last-modified\"\nexecute: \n  eval: true\n  echo: true\n  message: false\n  freeze: true\nformat: \n  html:\n    code-fold: false\n    code-summary: \"code chunk\"\n    number-sections: true\n    number-depth: 4\n---\n\n\n# Overview\n\nIn this hands-on exercise, we will learn how to compute Global Measures of Spatial Autocorrelation (GMSA) by using **spdep** package. By the end to this hands-on exercise, we will be able to:\n\n-   import geospatial data using appropriate function(s) of **sf** package,\n\n-   import csv file using appropriate function of **readr** package,\n\n-   perform relational join using appropriate join function of **dplyr** package,\n\n-   compute Global Spatial Autocorrelation (GSA) statistics by using appropriate functions of **spdep** package,\n\n    -   plot Moran scatterplot,\n\n    -   compute and plot spatial correlogram using appropriate function of **spdep** package.\n\n-   provide statistically correct interpretation of GSA statistics.\n\n# The Data\n\nWe will use following geospatial datasets in this exercise:\n\n| Dataset      | Description                                                    | Format         |\n|-------------------|--------------------------------|---------------------|\n| *Hunan*      | Hunan county boundary layer geospatial data                    | ESRI shapefile |\n| *Hunan_2012* | Contains selected Hunan’s local development indicators in 2012 | CSV file       |\n\n: {tbl-colwidths=\"\\[15,65,20\\]\"}\n\n# Installing and launching the R packages\n\n::: panel-tabset\n## Packages\n\nWe will use following packages in this exercise:\n\n| Package                                                     | Description                                                                                                                                                                                                          |\n|---------------------------|---------------------------------------------|\n| [**sf**](https://r-spatial.github.io/sf/)                   | Provides functions to manage, processing, and manipulate **Simple Features**, a formal geospatial data standard that specifies a storage and access model of spatial geometries such as points, lines, and polygons. |\n| [**spdep**](https://cran.r-project.org/web/packages/spdep/) | Provides collection of functions to create spatial weights matrix objects from polygon 'contiguities', from point patterns by distance and tessellations.                                                            |\n| [**tidyverse**](https://www.tidyverse.org/)                 | Provides collection of functions for performing data science task such as importing, tidying, wrangling data and visualising data.                                                                                   |\n| [**tmap**](https://cran.r-project.org/web/packages/tmap/)   | Provides functions for plotting cartographic quality static point patterns maps or interactive maps by using [leaflet](https://leafletjs.com/) API                                                                   |\n\n: {tbl-colwidths=\"\\[15,85\\]\"}\n\n## Code\n\nTo install and launch the four R packages.\n\n\n::: {.cell}\n\n```{.r .cell-code}\npacman::p_load(sf, spdep, tmap, tidyverse)\n```\n:::\n\n:::\n\n# Data Import and Preparation\n\n## Loading the data\n\nIn this section, we will learn how to bring a geospatial data and its associated attribute table into R environment. The geospatial data is in ESRI shapefile format and the attribute table is in csv fomat.\n\n::: panel-tabset\n## Import geospatial data\n\nWe use [*st_read()*](https://r-spatial.github.io/sf/reference/st_read.html) of **sf** package to import Hunan shapefile into R. The imported shapefile will be **simple features** Object of **sf**.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhunan <- st_read(dsn = \"data/geospatial\", \n                 layer = \"Hunan\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nReading layer `Hunan' from data source \n  `/Users/cham/project/Geospatial-Analytics/chrismanafe/ISSS626-GAA/hands_on_ex/hands_on_ex05/data/geospatial' \n  using driver `ESRI Shapefile'\nSimple feature collection with 88 features and 7 fields\nGeometry type: POLYGON\nDimension:     XY\nBounding box:  xmin: 108.7831 ymin: 24.6342 xmax: 114.2544 ymax: 30.12812\nGeodetic CRS:  WGS 84\n```\n\n\n:::\n:::\n\n::: {.cell}\n::: {.cell-output .cell-output-stdout}\n\n```\nRows: 88\nColumns: 8\n$ NAME_2     <chr> \"Changde\", \"Changde\", \"Changde\", \"Changde\", \"Changde\", \"Cha…\n$ ID_3       <int> 21098, 21100, 21101, 21102, 21103, 21104, 21109, 21110, 211…\n$ NAME_3     <chr> \"Anxiang\", \"Hanshou\", \"Jinshi\", \"Li\", \"Linli\", \"Shimen\", \"L…\n$ ENGTYPE_3  <chr> \"County\", \"County\", \"County City\", \"County\", \"County\", \"Cou…\n$ Shape_Leng <dbl> 1.869074, 2.360691, 1.425620, 3.474325, 2.289506, 4.171918,…\n$ Shape_Area <dbl> 0.10056190, 0.19978745, 0.05302413, 0.18908121, 0.11450357,…\n$ County     <chr> \"Anxiang\", \"Hanshou\", \"Jinshi\", \"Li\", \"Linli\", \"Shimen\", \"L…\n$ geometry   <POLYGON [°]> POLYGON ((112.0625 29.75523..., POLYGON ((112.2288 …\n```\n\n\n:::\n:::\n\n\n## Import aspatial data\n\nThen we will import *Hunan_2012.csv* into R by using *read_csv()* of **readr** package. The output is R dataframe class.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhunan2012 <- read_csv(\"data/aspatial/Hunan_2012.csv\")\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nRows: 88 Columns: 29\n── Column specification ────────────────────────────────────────────────────────\nDelimiter: \",\"\nchr  (2): County, City\ndbl (27): avg_wage, deposite, FAI, Gov_Rev, Gov_Exp, GDP, GDPPC, GIO, Loan, ...\n\nℹ Use `spec()` to retrieve the full column specification for this data.\nℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.\n```\n\n\n:::\n:::\n\n::: {.cell}\n::: {.cell-output .cell-output-stdout}\n\n```\nRows: 88\nColumns: 29\n$ County      <chr> \"Anhua\", \"Anren\", \"Anxiang\", \"Baojing\", \"Chaling\", \"Changn…\n$ City        <chr> \"Yiyang\", \"Chenzhou\", \"Changde\", \"Hunan West\", \"Zhuzhou\", …\n$ avg_wage    <dbl> 30544, 28058, 31935, 30843, 31251, 28518, 54540, 28597, 33…\n$ deposite    <dbl> 10967.0, 4598.9, 5517.2, 2250.0, 8241.4, 10860.0, 24332.0,…\n$ FAI         <dbl> 6831.7, 6386.1, 3541.0, 1005.4, 6508.4, 7920.0, 33624.0, 1…\n$ Gov_Rev     <dbl> 456.72, 220.57, 243.64, 192.59, 620.19, 769.86, 5350.00, 1…\n$ Gov_Exp     <dbl> 2703.0, 1454.7, 1779.5, 1379.1, 1947.0, 2631.6, 7885.5, 11…\n$ GDP         <dbl> 13225.0, 4941.2, 12482.0, 4087.9, 11585.0, 19886.0, 88009.…\n$ GDPPC       <dbl> 14567, 12761, 23667, 14563, 20078, 24418, 88656, 10132, 17…\n$ GIO         <dbl> 9276.90, 4189.20, 5108.90, 3623.50, 9157.70, 37392.00, 513…\n$ Loan        <dbl> 3954.90, 2555.30, 2806.90, 1253.70, 4287.40, 4242.80, 4053…\n$ NIPCR       <dbl> 3528.3, 3271.8, 7693.7, 4191.3, 3887.7, 9528.0, 17070.0, 3…\n$ Bed         <dbl> 2718, 970, 1931, 927, 1449, 3605, 3310, 582, 2170, 2179, 1…\n$ Emp         <dbl> 494.310, 290.820, 336.390, 195.170, 330.290, 548.610, 670.…\n$ EmpR        <dbl> 441.4, 255.4, 270.5, 145.6, 299.0, 415.1, 452.0, 127.6, 21…\n$ EmpRT       <dbl> 338.0, 99.4, 205.9, 116.4, 154.0, 273.7, 219.4, 94.4, 174.…\n$ Pri_Stu     <dbl> 54.175, 33.171, 19.584, 19.249, 33.906, 81.831, 59.151, 18…\n$ Sec_Stu     <dbl> 32.830, 17.505, 17.819, 11.831, 20.548, 44.485, 39.685, 7.…\n$ Household   <dbl> 290.4, 104.6, 148.1, 73.2, 148.7, 211.2, 300.3, 76.1, 139.…\n$ Household_R <dbl> 234.5, 121.9, 135.4, 69.9, 139.4, 211.7, 248.4, 59.6, 110.…\n$ NOIP        <dbl> 101, 34, 53, 18, 106, 115, 214, 17, 55, 70, 44, 84, 74, 17…\n$ Pop_R       <dbl> 670.3, 243.2, 346.0, 184.1, 301.6, 448.2, 475.1, 189.6, 31…\n$ RSCG        <dbl> 5760.60, 2386.40, 3957.90, 768.04, 4009.50, 5220.40, 22604…\n$ Pop_T       <dbl> 910.8, 388.7, 528.3, 281.3, 578.4, 816.3, 998.6, 256.7, 45…\n$ Agri        <dbl> 4942.253, 2357.764, 4524.410, 1118.561, 3793.550, 6430.782…\n$ Service     <dbl> 5414.5, 3814.1, 14100.0, 541.8, 5444.0, 13074.6, 17726.6, …\n$ Disp_Inc    <dbl> 12373, 16072, 16610, 13455, 20461, 20868, 183252, 12379, 1…\n$ RORP        <dbl> 0.7359464, 0.6256753, 0.6549309, 0.6544614, 0.5214385, 0.5…\n$ ROREmp      <dbl> 0.8929619, 0.8782065, 0.8041262, 0.7460163, 0.9052651, 0.7…\n```\n\n\n:::\n:::\n\n\n## Perform relational join\n\nWe will also update the attribute table of *hunan*’s SpatialPolygonsDataFrame with the attribute fields of *hunan2012* dataframe. This is performed by using *left_join()* of **dplyr** package.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncolnames(hunan)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"NAME_2\"     \"ID_3\"       \"NAME_3\"     \"ENGTYPE_3\"  \"Shape_Leng\"\n[6] \"Shape_Area\" \"County\"     \"geometry\"  \n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ncolnames(hunan2012)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1] \"County\"      \"City\"        \"avg_wage\"    \"deposite\"    \"FAI\"        \n [6] \"Gov_Rev\"     \"Gov_Exp\"     \"GDP\"         \"GDPPC\"       \"GIO\"        \n[11] \"Loan\"        \"NIPCR\"       \"Bed\"         \"Emp\"         \"EmpR\"       \n[16] \"EmpRT\"       \"Pri_Stu\"     \"Sec_Stu\"     \"Household\"   \"Household_R\"\n[21] \"NOIP\"        \"Pop_R\"       \"RSCG\"        \"Pop_T\"       \"Agri\"       \n[26] \"Service\"     \"Disp_Inc\"    \"RORP\"        \"ROREmp\"     \n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nhunan <- left_join(hunan,hunan2012) %>%\n  select(1:4, 7, 15)\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nJoining with `by = join_by(County)`\n```\n\n\n:::\n:::\n\n::: {.cell}\n::: {.cell-output .cell-output-stdout}\n\n```\nRows: 88\nColumns: 7\n$ NAME_2    <chr> \"Changde\", \"Changde\", \"Changde\", \"Changde\", \"Changde\", \"Chan…\n$ ID_3      <int> 21098, 21100, 21101, 21102, 21103, 21104, 21109, 21110, 2111…\n$ NAME_3    <chr> \"Anxiang\", \"Hanshou\", \"Jinshi\", \"Li\", \"Linli\", \"Shimen\", \"Li…\n$ ENGTYPE_3 <chr> \"County\", \"County\", \"County City\", \"County\", \"County\", \"Coun…\n$ County    <chr> \"Anxiang\", \"Hanshou\", \"Jinshi\", \"Li\", \"Linli\", \"Shimen\", \"Li…\n$ GDPPC     <dbl> 23667, 20981, 34592, 24473, 25554, 27137, 63118, 62202, 7066…\n$ geometry  <POLYGON [°]> POLYGON ((112.0625 29.75523..., POLYGON ((112.2288 2…\n```\n\n\n:::\n:::\n\n:::\n\n## Visualising Regional Development Indicator\n\nNow, we are going to prepare a basemap and a choropleth map showing the distribution of GDPPC 2012 by using `qtm()` of **tmap** package.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nequal <- tm_shape(hunan) +\n  tm_fill(\"GDPPC\",\n          n = 5,\n          style = \"equal\") +\n  tm_borders(alpha = 0.5) +\n  tm_layout(main.title = \"Equal interval classification\")\n\nquantile <- tm_shape(hunan) +\n  tm_fill(\"GDPPC\",\n          n = 5,\n          style = \"quantile\") +\n  tm_borders(alpha = 0.5) +\n  tm_layout(main.title = \"Equal quantile classification\")\n\ntmap_arrange(equal, \n             quantile, \n             asp=1, \n             ncol=2)\n```\n\n::: {.cell-output-display}\n![](hands_on_ex05.1_files/figure-html/unnamed-chunk-10-1.png){width=1536}\n:::\n:::\n\n\n# Global Measures of Spatial Autocorrelation\n\nIn this section, we will learn how to compute global spatial autocorrelation statistics and to perform spatial complete randomness test for global spatial autocorrelation.\n\n### Computing Contiguity Spatial Weights\n\nBefore we can compute the global spatial autocorrelation statistics, we need to construct a spatial weights of the study area. The spatial weights is used to define the neighbourhood relationships between the geographical units (i.e. county) in the study area.\n\n> [`poly2nb()`](https://r-spatial.github.io/spdep/reference/poly2nb.html) of **spdep** package is used to compute contiguity weight matrices for the study area. This function builds a neighbours list based on regions with contiguous boundaries. If you look at the documentation you will see that you can pass a “queen” argument that takes TRUE or FALSE as options. If you do not specify this argument the default is set to TRUE, that is, if you don’t specify queen = FALSE this function will return a list of first order neighbours using the Queen criteria.\n\nMore specifically, the code chunk below is used to compute Queen contiguity weight matrix.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nwm_q <- poly2nb(hunan, \n                queen=TRUE)\nsummary(wm_q)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nNeighbour list object:\nNumber of regions: 88 \nNumber of nonzero links: 448 \nPercentage nonzero weights: 5.785124 \nAverage number of links: 5.090909 \nLink number distribution:\n\n 1  2  3  4  5  6  7  8  9 11 \n 2  2 12 16 24 14 11  4  2  1 \n2 least connected regions:\n30 65 with 1 link\n1 most connected region:\n85 with 11 links\n```\n\n\n:::\n:::\n\n\n::: callout-note\n-   There are 88 area units in Hunan.\n\n-   The most connected area unit has 11 neighbours.\n\n-   There are two area units with only one neighbour.\n:::\n\n### Row-standardised weights matrix\n\nNext, we need to assign weights to each neighboring polygon. In our case, each neighboring polygon will be assigned equal weight (style=“W”). This is accomplished by assigning the fraction 1/(#ofneighbors) to each neighboring county then summing the weighted income values.\n\n> While this is the most intuitive way to summaries the neighbors’ values it has one drawback in that polygons along the edges of the study area will base their lagged values on fewer polygons thus potentially over- or under-estimating the true nature of the spatial autocorrelation in the data.\n>\n> For this example, we’ll stick with the style=“W” option for simplicity’s sake but note that other more robust options are available, notably style=“B”.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrswm_q <- nb2listw(wm_q, \n                   style=\"W\", \n                   zero.policy = TRUE)\nrswm_q\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nCharacteristics of weights list object:\nNeighbour list object:\nNumber of regions: 88 \nNumber of nonzero links: 448 \nPercentage nonzero weights: 5.785124 \nAverage number of links: 5.090909 \n\nWeights style: W \nWeights constants summary:\n   n   nn S0       S1       S2\nW 88 7744 88 37.86334 365.9147\n```\n\n\n:::\n:::\n\n\n::: callout-important\n-   The input of [`nb2listw()`](https://r-spatial.github.io/spdep/reference/nb2listw.html) must be an object of class **nb**. The syntax of the function has two major arguments, namely style and zero.poly.\n\n-   *style* can take values “W”, “B”, “C”, “U”, “minmax” and “S”.\n\n    -   B is the basic binary coding,\n    -   W is row standardised (sums over all links to n),\n    -   C is globally standardised (sums over all links to n),\n    -   U is equal to C divided by the number of neighbours (sums over all links to unity),\n    -   S is the variance-stabilizing coding scheme proposed by Tiefelsdorf et al. 1999, p. 167-168 (sums over all links to n).\n\n-   If *zero policy* is set to TRUE, weights vectors of zero length are inserted for regions without neighbour in the neighbours list. These will in turn generate lag values of zero, equivalent to the sum of products of the zero row t(rep(0, length=length(neighbours))) %\\*% x, for arbitrary numerical vector x of length length(neighbours). The spatially lagged value of x for the zero-neighbour region will then be zero, which may (or may not) be a sensible choice.\n:::\n\n# Global Measures of Spatial Autocorrelation: Moran’s I\n\nIn this section, we will learn how to perform Moran’s I statistics testing by using [`moran.test()`](https://r-spatial.github.io/spdep/reference/moran.test.html) of **spdep**.\n\n::: panel-tabset\n## Moran's I test\n\nLet us perform Moran’s I statistical testing using [`moran.test()`](https://r-spatial.github.io/spdep/reference/moran.test.html) of **spdep**.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmoran.test(hunan$GDPPC, \n           listw=rswm_q, \n           zero.policy = TRUE, \n           na.action=na.omit)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n\n\tMoran I test under randomisation\n\ndata:  hunan$GDPPC  \nweights: rswm_q    \n\nMoran I statistic standard deviate = 4.7351, p-value = 1.095e-06\nalternative hypothesis: greater\nsample estimates:\nMoran I statistic       Expectation          Variance \n      0.300749970      -0.011494253       0.004348351 \n```\n\n\n:::\n:::\n\n\n::: callout-note\n**Question: What statistical conclusion can you draw from the output above?**\n\n-   The p-value which is 1.095e-06, which is very small\n\n-   We will **reject** the null hypothesis at 99.9% as the p-value is smaller than our alpha value.\n\n-   Since the Moran I statistic 0.300749970 is \\> 0 and is approaching 1 which is positive autocorrelation, we can infer that spatial patterns resemble a cluster.\n:::\n\n## Monte Carlo Moran’s I\n\nLet us also perform permutation test for Moran’s I statistic by using [`moran.mc()`](https://r-spatial.github.io/spdep/reference/moran.mc.html) of **spdep**. A total of 1000 simulation will be performed.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nset.seed(1234)\nbperm= moran.mc(hunan$GDPPC, \n                listw=rswm_q, \n                nsim=999, \n                zero.policy = TRUE, \n                na.action=na.omit)\nbperm\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n\n\tMonte-Carlo simulation of Moran I\n\ndata:  hunan$GDPPC \nweights: rswm_q  \nnumber of simulations + 1: 1000 \n\nstatistic = 0.30075, observed rank = 1000, p-value = 0.001\nalternative hypothesis: greater\n```\n\n\n:::\n:::\n\n\n::: callout-note\n**Question: What statistical conclusion can you draw from the output above?**\n\n-   After 999 simulations, our P-value is 0.001.\n\n-   We will **accept** / **do not reject** the null hypothesis at 99.9% as the p-value is equal to our alpha value 0.001.\n\n-   Since the Monte Carlo statistic 0.30075 is \\> 0 and is approaching 1 which is positive autocorrelation, we can infer that spatial patterns that we observed resemble a cluster.\n:::\n\n## Visualising Monte Carlo Moran’s I\n\nWe can examine the simulated Moran’s I test statistics in greater detail by plotting the distribution of the statistical values as a histogram.\n\nWe will use [`hist()`](https://www.rdocumentation.org/packages/graphics/versions/3.6.2/topics/hist) and [`abline()`](https://www.rdocumentation.org/packages/graphics/versions/3.6.2/topics/abline) of R Graphics to visualise the test statistics.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmean(bperm$res[1:999])\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] -0.01504572\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nvar(bperm$res[1:999])\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 0.004371574\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nsummary(bperm$res[1:999])\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n    Min.  1st Qu.   Median     Mean  3rd Qu.     Max. \n-0.18339 -0.06168 -0.02125 -0.01505  0.02611  0.27593 \n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nhist(bperm$res, \n     freq=TRUE, \n     breaks=20, \n     xlab=\"Simulated Moran's I\")\nabline(v=0, \n       col=\"red\")\n```\n\n::: {.cell-output-display}\n![](hands_on_ex05.1_files/figure-html/unnamed-chunk-18-1.png){width=672}\n:::\n:::\n\n\nWe also able to plot the values by using `ggplot2` package.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngg <- bperm$res\nmu <- mean(gg)\n\nggplot(data=data.frame(gg),\n       aes(x=gg)\n  ) +\n  geom_histogram(\n    bins = 30,\n    size = 0.2,\n    color = \"black\"\n  ) +\n  geom_vline(\n    xintercept = mu,\n    color=\"red\",\n    linetype = \"solid\"\n  ) +\n  labs(title =\"Histogram of bperm$res\",\n    x = \"Simulated Moran's I\",\n    y = \"Frequency\"\n  ) +\n  theme(\n    plot.title = element_text(hjust = 0.5),\n  )\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nWarning: Using `size` aesthetic for lines was deprecated in ggplot2 3.4.0.\nℹ Please use `linewidth` instead.\n```\n\n\n:::\n\n::: {.cell-output-display}\n![](hands_on_ex05.1_files/figure-html/unnamed-chunk-19-1.png){width=672}\n:::\n:::\n\n\n::: callout-note\n**Question: What statistical observation can we draw from the output?**\n\n-   The observed Moran's I, as indicated by the red line, is substantially larger than the bulk of the simulated values, which implies that the observed spatial autocorrelation in the data is **significantly different from random chance**.\n\n-   Since most of the simulated values are close to 0 and the observed Moran’s I is positive and beyond the central bulk of the distribution, we can infer that the spatial autocorrelation in your data is significant. This suggests that similar values (in terms of the variable you are analyzing) are **spatially clustered**.\n:::\n:::\n\n# Global Measures of Spatial Autocorrelation: Geary’s C\n\nIn this section, we will learn how to perform Geary’s C statistics testing by using appropriate functions of **spdep** package.\n\n::: panel-tabset\n## Geary’s C test\n\nWe will perform Geary’s C test for spatial autocorrelation by using [`geary.test()`](https://r-spatial.github.io/spdep/reference/geary.test.html) of **spdep**.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngeary.test(hunan$GDPPC, listw=rswm_q)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n\n\tGeary C test under randomisation\n\ndata:  hunan$GDPPC \nweights: rswm_q   \n\nGeary C statistic standard deviate = 3.6108, p-value = 0.0001526\nalternative hypothesis: Expectation greater than statistic\nsample estimates:\nGeary C statistic       Expectation          Variance \n        0.6907223         1.0000000         0.0073364 \n```\n\n\n:::\n:::\n\n\n::: callout-note\n**Question: What statistical conclusion can we draw from the output above?**\n\nThe Geary’s C statistic for \\`GDPPC\\` is 0.6907, indicating \\*\\*positive spatial autocorrelation\\*\\*. This suggests that regions with similar GDP per capita are spatially clustered. The standard deviate of 3.6108 and the p-value of 0.0001526 provide strong evidence against the null hypothesis of no spatial autocorrelation, confirming that the observed pattern is clustered.\n:::\n\n## Computing Monte Carlo Geary’s C\n\nLet us perform permutation test for Geary’s C statistic by using [`geary.mc()`](https://r-spatial.github.io/spdep/reference/geary.mc.html) of **spdep**.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nset.seed(1234)\nbperm=geary.mc(hunan$GDPPC, \n               listw=rswm_q, \n               nsim=999)\nbperm\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n\n\tMonte-Carlo simulation of Geary C\n\ndata:  hunan$GDPPC \nweights: rswm_q  \nnumber of simulations + 1: 1000 \n\nstatistic = 0.69072, observed rank = 1, p-value = 0.001\nalternative hypothesis: greater\n```\n\n\n:::\n:::\n\n\n::: callout-note\n**Question: What statistical conclusion can we draw from the output above?**\n\n-   After running all simulations, the p-value = 0.001.\n\n-   Hence, we will **accept** / **cannot reject** the null hypothesis at 99.9% as the p-value is equal to our alpha value, 0.001.\n\n-   The Geary C statistic is now, 0.69072, which is still \\< 1, hence the spatial pattern is “clustered”.\n:::\n\n## Visualising the Monte Carlo Geary’s C\n\nNext, we will plot a histogram to reveal the distribution of the simulated values by using the code chunk below.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmean(bperm$res[1:999])\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1.004402\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nvar(bperm$res[1:999])\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 0.007436493\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nsummary(bperm$res[1:999])\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. \n 0.7142  0.9502  1.0052  1.0044  1.0595  1.2722 \n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nhist(bperm$res, freq=TRUE, breaks=20, xlab=\"Simulated Geary c\")\nabline(v=1, col=\"red\") \n```\n\n::: {.cell-output-display}\n![](hands_on_ex05.1_files/figure-html/unnamed-chunk-25-1.png){width=672}\n:::\n:::\n\n\n::: callout-note\n**Question: What statistical observation can we draw from the output?**\n\nThe histogram of simulated Geary's C values shows that most of the simulated statistics cluster around 1, indicating random spatial patterns. However, the observed Geary's C statistic is much lower, indicating significant **spatial clustering** of similar values. This supports the conclusion that the spatial pattern in the data is **not random** but exhibits **positive spatial autocorrelation**.\n:::\n:::\n\n# Spatial Correlogram\n\n**Spatial correlograms** are a useful tool for examining patterns of spatial autocorrelation in your data or model residuals. They show how the correlation between pairs of spatial observations changes as the distance (lag) between them increases. Correlograms plot an index of autocorrelation, such as **Moran’s I** or **Geary’s C**, against distance.\n\nAlthough correlograms are not as fundamental as **variograms** (a cornerstone concept in geostatistics), they serve as a valuable exploratory and descriptive tool. In fact, for many purposes, correlograms can provide richer information than variograms.\n\n::: panel-tabset\n## Moran’s I correlogram\n\nWe will use the [`sp.correlogram()`](https://r-spatial.github.io/spdep/reference/sp.correlogram.html) function from the **spdep** package to compute a 6-lag spatial correlogram for **GDPPC**, using **Moran’s I** to assess global spatial autocorrelation. The results will then be plotted using the base `plot()` function in R.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nMI_corr <- sp.correlogram(wm_q, \n                          hunan$GDPPC, \n                          order=6, \n                          method=\"I\", \n                          style=\"W\")\nplot(MI_corr)\n```\n\n::: {.cell-output-display}\n![](hands_on_ex05.1_files/figure-html/unnamed-chunk-26-1.png){width=672}\n:::\n:::\n\n\n> Plotting the output alone might not provide a complete interpretation, as not all autocorrelation values may be statistically significant. Therefore, it's important to examine the full analysis by printing the detailed results, as shown in the code chunk below.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nprint(MI_corr)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nSpatial correlogram for hunan$GDPPC \nmethod: Moran's I\n         estimate expectation   variance standard deviate Pr(I) two sided    \n1 (88)  0.3007500  -0.0114943  0.0043484           4.7351       2.189e-06 ***\n2 (88)  0.2060084  -0.0114943  0.0020962           4.7505       2.029e-06 ***\n3 (88)  0.0668273  -0.0114943  0.0014602           2.0496        0.040400 *  \n4 (88)  0.0299470  -0.0114943  0.0011717           1.2107        0.226015    \n5 (88) -0.1530471  -0.0114943  0.0012440          -4.0134       5.984e-05 ***\n6 (88) -0.1187070  -0.0114943  0.0016791          -2.6164        0.008886 ** \n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n```\n\n\n:::\n:::\n\n\n::: callout-note\nQuestion: What statistical observation can we draw from the plot above?\n\n-   Positive Moran’s I values for shorter lags (1–3), reflecting spatial clustering of similar values.\n\n-   Negative Moran’s I values for longer lags (5–6), indicating spatial divergence of values.\n\n-   Error bars help visualize the variability and significance of these estimates. Significant values (lags 1, 2, 3, 5, and 6) stand out more due to their separation from zero, while lag 4 hovers around zero and is not statistically significant.\n\nThis pattern suggests that similar GDP per capita values are clustered spatially at short distances, but regions farther apart are more likely to have contrasting GDP per capita values.\n:::\n\n## Geary’s C correlogram\n\nWe will use `sp.correlogram()` function from the **spdep** package to compute a 6-lag spatial correlogram for **GDPPC**, using **Geary’s C** to assess global spatial autocorrelation. The results will then be plotted using the base `plot()` function in R.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nGC_corr <- sp.correlogram(wm_q, \n                          hunan$GDPPC, \n                          order=6, \n                          method=\"C\", \n                          style=\"W\")\nplot(GC_corr)\n```\n\n::: {.cell-output-display}\n![](hands_on_ex05.1_files/figure-html/unnamed-chunk-28-1.png){width=672}\n:::\n:::\n\n\nLet us see the analysis report\n\n\n::: {.cell}\n\n```{.r .cell-code}\nprint(GC_corr)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nSpatial correlogram for hunan$GDPPC \nmethod: Geary's C\n        estimate expectation  variance standard deviate Pr(I) two sided    \n1 (88) 0.6907223   1.0000000 0.0073364          -3.6108       0.0003052 ***\n2 (88) 0.7630197   1.0000000 0.0049126          -3.3811       0.0007220 ***\n3 (88) 0.9397299   1.0000000 0.0049005          -0.8610       0.3892612    \n4 (88) 1.0098462   1.0000000 0.0039631           0.1564       0.8757128    \n5 (88) 1.2008204   1.0000000 0.0035568           3.3673       0.0007592 ***\n6 (88) 1.0773386   1.0000000 0.0058042           1.0151       0.3100407    \n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n```\n\n\n:::\n:::\n\n:::\n\n# Reference\n\nKam, T. S. Global Measures of Spatial Autocorrelation. *R for Geospatial Data Science and Analytics.* <https://r4gdsa.netlify.app/chap09.html>\n",
    "supporting": [
      "hands_on_ex05.1_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}